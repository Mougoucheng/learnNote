<center><font size=7 color="silver"> 代码整洁之道 </font></center>
<center><font size=6 color="gray"> 程序员的职业素养 </font></center>
<center><font size=5 color="gray"> The Clean Coder </font></center>
<center><font size=4 color="gray"> A code of Conduct for Professional Programmers </font></center>

# 第一章、专业主义
## 1.清楚你要什么

## 2.担当责任

## 3.首先，不行损害之事

### 1.不破坏软件功能

* 让QA找不出任何问题

* 要确信代码正常运行

  测试驱动开发（TDD)  ：要设计易于测试的代码，最好是先写测试，再写要测的代码

* 自动化QA

### 2.不要破坏结构

* 要想证明软件易于修改，唯一办法就是做些实际的修改。  
  如果你希望自己的软件灵活可变，那就应该时常修改它！

## 4.职业道德 
### 1.了解你的领域
下面列出每个专业软件软件开发人员必须精通的事项。
* 设计模式：必须能描述GOF书中的全部24种模式，同时还要有POSA书中的多数模式的实战经验。
* 设计原则：必须了解SOLID原则，而且要深刻理解组件设计原则。
* 方法：必须理解XP、Scrum、精益、看板、瀑布、结构化分析及结构化设计等。
* 实践：必须掌握测试驱动开发、面向对象设计、结构化编程、持续集成和结对编程。
* 工件：必须了解如何使用UML图、DFD图、结构图、Petri网络图、状态迁移图表、流程图和决策表。

### 2.坚持学习

### 3.练习

### 4.合作

### 5.辅导

### 6.了解业务领域

### 7.与雇主/客户保持一致

### 8.谦逊

### 参考文献

* Robert C. Martin, Principles, Patterns, and Practices of Agile Software Development, Upper Saddle River, Nj:Prentice Hall, 2002

# 第二章、说“不”

## 1.对抗角色

## 2.高风险时刻

## 3.要有团队精神

### a.试试看

### b.消极对抗

## 4.说“是”的成本

## 5.如何写出好代码

# 第三章、说“是”

## 1.承诺用语

### a.识别“缺乏承诺”的征兆

以下几个用词和短语，会透露"缺乏承诺"的蛛丝马迹

* **`需要/应当`**
* **`希望/但愿`**
* **`让我们`**（而不是"让我"）

### b.真正的承诺听起来是怎样的

识别真正的承诺的诀窍在于，要去搜寻与下列相似的语句：

* **`我将在……之前……`**（例如，我将在周二之前完成这个任务。）
* 言必信，行必果

没能做到"`言必信，行必果`"的一些可能原因和应对方法：

* 之所以没成功，是因为我寄希望于某某去做这件事。
  * `最终目标依赖于他人，那么就应该采取某些具体行动，接近最终目标`
* 之所以没成功，是因为我不太确信是否真能完成的了。
  * `即使目标无法达成，仍要全力前进，离目标更近些`
* 之所以没成功，是因为有些时候我真的无能为力。
  * `有些事情无法预料可能导致目标无法完成时，尽早发出预警，越快越好`

### c.总结

## 2.学习如何说“是”

### a.“试一试”的另一面

### b.坚守原则

## 3.结论

# 第四章、编码

## 1.做好准备

**`编码比其他类型的活动要求更加聚精会神，如果感到疲劳或者心烦意乱，千万不要编码`**

* `首先，代码必须能够正常工作。`
  * 必须理解当前要解决的是什么问题以及该如何解决
  * 必须确保编写的代码忠实遵循解决方案
  * 必须管理好解决方案的每一处细节，并且使语言、平台、现有架构以及当前系统的所有问题和平共处
* `代码必须能够帮你解决客户提出的问题。`
  * 发现客户的潜在或者真正的问题所在，并就之与客户进行交流，以确保代码能够满足客户的真实需求
* `代码必须要能和现有系统结合得天衣无缝。`
  * 编写代码时必须遵循稳健的工程原则，以确保妥善管理好各种依赖关系，不让系统变得更僵硬、更脆弱、更晦涩
* `其他程序员必须能读懂你的代码。`
  * 不仅包括写好注释，还包括要精心锤炼代码，使它能够表达自己的编程意图

### a.凌晨3点写出的代码

* 疲劳的时候，千万不要写代码。

### b.焦虑时写下的代码

* 焦虑的时候，不该写代码。
  * 花专门的一块时间，处理造成焦虑的问题，而不是强迫自己忍受着内心的焦虑煎熬继续编程
  * 理想情况下，应该使用私人时间去解决私人问题
  * 另一方面，如果发现自己虽然人坐在办公室里，但内心的焦虑正在不断削弱工作效率，那么最好还是花上一个小时让它们先安静下来。

## 2.流态区

### a.音乐

### b.中断

## 3.阻塞

## 4.调试

## 5.保持节奏

### a.知道何时应该离开一会儿

### b.开车回家路上

### c.洗澡

## 6.进度延迟

## 7.帮助

## 8.参考文献

# 第五章、测试驱动开发

## 1.此事已有定论

## 2.TDD的三项法则

测试驱动开发(Test Driven Development)

* 在编好失败单元测试之前，不要编写任何产品代码。
* 只要有一个单元测试失败了，就不要再写测试代码；无法通过编译也是一种失败情况。
* 产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写。

## 3.TDD的优势

* 提升代码确定性
* 降低代码缺陷率
* 给程序员勇气、鼓励
* 优化文档
* 优化设计
* 专业人士的选择

## 4.TDD的局限

## 5.参考文献

# 第六章、练习

## 1.引子

## 2.编程柔道场

卡塔练习：

* http://katas.softwarecraftsmanship.org
* http://codekata.pragprog.com
* 保龄球：http://butunclebob.com/ArticleS.UncleBob.TheBowlingGameKata
* 素因子：http://butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata
* 自动换行：http://thecleancoder.blogspot.com/2010/10/craftman-62-dark-path.html

## 3.自身经验的拓展

## 4.结论

## 5.参考文献

# 第七章、验收测试

## 1.需求的沟通

### 1.过早精细化

* 不确定原则
* 预估焦虑

### 2.迟来的模糊性

## 2.验收测试

* 验收测试的定义为：业务方与开发方合作编写的测试，其目的在于确定需求已经完成。
* 验收测试的目的是：沟通、澄清、精确化。
  * 开发方、业务方、测试方对验收测试达成公式，大家都能明白系统的行为将会是怎样。各方都应当记录这种准确的共识。
* 验收测试都应当自动进行。
  * 考虑成本原因，在软件开发的周期中，验收测试不应当手工进行。
* 理想状态下，业务方和QA会协作编写验收测试，程序员来检查测试之间是否有冲突或矛盾。
  * 但通常由于时间问题，会把测试交给业务分析员、QA甚至是开发人员。如果只能由开发人员来写测试，应当确保写测试的程序员与开发功能的程序员不是同一个人。
* 遵循“推迟精细化”的原则
  * 验收测试应该越晚越好，通常是功能执行完成的前几天。
* 验收测试不是单元测试。
  * 单元测试是程序员写给程序员的，它是正式的设计文档，描述了底层结构及代码的行为。关心单元测试结果的是程序员而不是业务人员。
  * 验收测试是业务方写给业务方的（虽然可能最后是身为开发者的你来写）。它们是正式的需求文档，描述了业务方认为系统应该如何运行。关心验收测试结果的是业务方和程序员。
* 持续集成
  * 务必确保在持续集成系统中，单元测试和验收测试每天都能运行好几次。整套持续集成系统应该由源代码管理系统来触发。只要有人提交了代码，持续集成系统就会开始构建，并运行所有的测试，测试结果会用电子邮件发送给团队所有人。
  * 持续集成不应该失败，失败的集成应该视为紧急情况，如果失败了，团队里的所有人都应该停下手里的活，看看如何让测试通过。

## 3.结论

要解决开发方和业务方沟通问题，有效的办法就是编写自动化的验收测试，这些测试就是无可挑剔的需求文档。

# 第八章、测试策略

## 1.QA应该找不到任何错误

## 2.自动化测试金字塔

* 单元测试
  * 目的是：在最低层次上来定义系统
  * 规约是：先写测试，再编写代码
  * 作为持续集成的一部风来运行以确保程序员的代码意图没有遭到破坏
  * 真实覆盖率应该保持90%以上
* 组件测试
  * 系统的组件封装了业务规则，对组件的测试便是对其中业务规则的验收测试。
  * 由QA和业务人员编写，开发人员提供辅助。在FitNesse、JBebave或Cucumber等组件测试环境下编写。让不具备编写测试能力的业务人员也能理解这些测试。
  * 组件测试差不多可以覆盖系统的50%
  * 测试的是成功路径、明显的极端情况、边界状态、可选路径
* 集成测试
  * 只针对那些组件很多的较大型系统
  * 编排性测试，主要测试组件装配在一起时是否协调，彼此通信畅通
  * 由系统架构师或主设计师来编写，用以确认系统架构层面的结构是否正确无误。（在这个层次上，也许已经可以进行性能测试和吞吐率测试了。）
* 系统测试
  * 针对整个集成完毕的系统来运行的自动化测试，是最终的集成测试，目的是确保正确的系统构造。
  * 测试系统是否已正确组装完毕，以及系统各个组成部件之间是否能正确交互。（应该包含性能测试和吞吐率测试）
  * 由系统架构师和技术负责人来编写，测试周期视测试运行时间长短而定，一般不会过于频繁，但越频繁越好
  * 系统测试约占测试的10%。
* 人工探索式测试
  * 需要人工介入、敲击键盘、盯牢屏幕的测试
  * 确保系统在人工操作下表现良好，同时富有创造性地找出尽可能多的“古怪之处”

## 3.结论

## 4.参考文献

# 第九章、时间管理

## 1.会议



## 2.注意力点数

## 3.时间拆分和番茄工作法

## 4.要避免的行为

## 5.死胡同

## 6.泥潭

## 7.结论

# 第十章、预估

## 1.什么是预估

## 2.PERT

## 3.预估任务

## 4.大数定律

## 5.结论

## 6.参考文献

# 第十一章、压力

## 1.避免压力

## 2.应对压力

## 3.结论

# 第十二章、协作

## 1.程序员与人

## 2.小脑

## 3.结论

# 第十三章、团队与项目

## 1.只是简单混合吗

## 2.结论

## 3.参考文献

# 第十四章、辅导、学徒期与技艺

## 1.失败的学位教育

## 2.辅导

## 3.学徒期

## 4.技艺

## 5.结论



# 附录 工具